SEP 007 -- combinatorial assemblies initial draft
===================================

SEP                     | <leave empty>
----------------------|--------------
**Title**                | combinatorial assemblies
**Authors**           | Matthew Pocock, Jacob Beal, Nicholas Roehner (nicholasroehner@gmail.com)
**Editor**            | Raik Gruenberg
**Type**               | Data Model
**SBOL Version** | 2.2
**Status**             | Draft
**Created**          | 19-Aug-2016
**Last modified**  |

Abstract
-----------

We propose adding two new classes, `ComponentDerivation` and `Alternative`, to allow users to represent basic combinatorial designs in SBOL without having to enumerate every possible design variant. For example, a user may wish to encode a library of reporter gene variants that have different promoters and ribosome binding sites (RBS) without having to create a `ComponentDefinition` for every possible combination of a promoter, RBS, and coding sequence (CDS) in their library. A `ComponentDerivation` refers to a single template `ComponentDefinition` from which new `ComponentDefinition` objects can be derived. Each `Alternative` in a `ComponentDerivation` specifies one or more possible definitions for any new sub-`Component` object derived from a `Component` in the template `ComponentDefinition`.

We also propose adding http://sbols.org/v2#differentFrom to the list of recommended URIs for the `restriction` property of the `SequenceConstraint` class. This would enable users to specify combinatorial designs in which the choice of a definition for one `Component` during a derivation can preclude the choice of that definition for another `Component` during the same derivation.

1. Rationale <a name="rationale"></a>
----------------

This SEP was initiated in response to [SBOL-Specification/#31]. Currently, there is no way to specify the composition of a genetic library or another combinatorial design for common use cases in synthetic biology, such as tuning the performance of a genetic circuit or biosynthetic pathway through combinatorial DNA assembly and screening. While a user could derive multiple `ComponentDefinition` objects from an abstract `ComponentDefinition` that lacks a `Sequence` or a total ordering of its sub-`Component` objects via `SequenceConstraint` objects, they would still be unable to use SBOL to specify a finite set of alternative structures to choose from during such a derivation. This SEP is intended to enable users of SBOL to explicitly denote the structural choices to be made and the basic strategy to be used (enumerate vs. sample) during the derivation of a `ComponentDefinition` in accordance with a combinatorial design. 

2. Specification <a name="specification"></a>
----------------------------------------------

Here we define two new classes, `ComponentDerivation` and `Alternative`, and provide an update to Table 9 of the SBOL 2.1.0 specification, adding http://sbols.org/v2#differentFrom to the list of recommended URIs for the `restriction` property of the `SequenceConstraint` class.

### 2.1 ComponentDerivation

The `ComponentDerivation` class can be used to specify a combinatorial design. `ComponentDefinition` objects that realize the design can be derived in accordance with the class properties `using`, `alternatives`, and `strategy` (Figure 1).

![Component Derivation class UML diagram](images/component_derivation.png "Component Derivation class UML diagram")

**Figure 1:** Diagram of the `ComponentDerivation` class and its associated properties

#### 2.1.1 ComponentDerivation.using

The `using` property is REQUIRED and MUST contain a URI that refers to a `ComponentDefinition`. This `ComponentDefinition` (referred to hereafter as the template `ComponentDefinition`) is expected to serve as a template for the derivation of new `ComponentDefinition` objects. Consequently, its `components` property SHOULD contain one or more `Component` objects that describe its substructure (referred to hereafter as template `Component` objects), and its `sequenceConstraints` property MAY also contain one or more `SequenceConstraint` objects that constrain this substructure. 

When a `ComponentDefinition` is derived in accordance with a `ComponentDerivation`, the `wasDerivedFrom` property of the derived `ComponentDefinition` SHOULD refer to the `ComponentDerivation`. When multiple `ComponentDefinition` are derived in accordance with the same `ComponentDerivation`, they MAY be referred to by the `members` property of a `Collection`, in which case the `wasDerivedFrom` property of the `Collection` SHOULD also refer to this `ComponentDerivation`.

If the `types` property of the template `ComponentDefinition` contains one or more URIs, then the `types` property of the derived `ComponentDefinition` SHOULD also contain those URIs. The same holds true for the `roles` properties of these `ComponentDefinition` objects. For each template `Component` in the template `ComponentDefinition`, the `components` property of the derived `ComponentDefinition` SHOULD contain one `Component` with a `wasDerivedFrom` property that refers to the template `Component`. Finally, the derived `Component` objects MUST follow the `restriction` properties of any `SequenceConstraint` objects that refer to their corresponding template `Component` objects.

#### 2.1.2 ComponentDerivation.alternatives

The `alternatives` property is OPTIONAL and MAY contain a set of `Alternative` objects. These `Alternative` objects are expected to denote the choices available when deriving a new `ComponentDefinition` in accordance with a `ComponentDerivation`. Each template `Component` referred to by the `at` property of an `Alternative` MUST be contained by the `components` property of the template `ComponentDefinition`. In addition, the `alternatives` property MUST NOT contain two or more `Alternative` objects that refer to the same template `Component` via their `at` properties.

#### 2.1.3 ComponentDerivation.strategy

The `strategy` property is OPTIONAL and has a data type of URI. Table 1 provides a list of REQUIRED strategy URIs. If the `strategy` property is not empty, then it MUST contain a URI from Table 1. This property recommends how many `ComponentDefinition` objects a user SHOULD derive from the template `ComponentDefinition`.

**Table 1:** REQUIRED URIs for the `strategy` property

| Strategy URI                   | Description |
|-----------------------------------|-------------|
| http://sbols.org/v2#enumerate | A user SHOULD derive all `ComponentDefinition` objects that are consistent with the template `ComponentDefinition`. |
| http://sbols.org/v2#sample    | A user SHOULD derive a subset of all `ComponentDefinition` objects that are consistent with the template `ComponentDefinition`. The manner in which this subset is chosen is left to the user. |

### 2.2 Alternative

The `Alternative` class can be used to specify a choice of `ComponentDefinition` objects for any new `Component` derived from a template `Component` in the template `ComponentDefinition`. This specification is made using the class properties `at`, `from`, and/or `fromCollection` (Figure 2). While the `from` and `fromCollection` properties are OPTIONAL, at least one of them MUST NOT be empty.

![Alternative class UML diagram](images/alternative.png "Alternative class UML diagram")

**Figure 2:** Diagram of the `Alternative` class and its associated properties

#### 2.2.1 Alternative.at

The `at` property is REQUIRED and MUST contain a URI that refers to a template `Component` in the template `ComponentDefinition`. If the `wasDerivedFrom` property of a `Component` refers to this template `Component`, then the `definition` property of the derived `Component` MUST refer to one of the `ComponentDefinition` objects referred to by the `from` property of the `Alternative`. If not, then this `definition` property MUST refer to one of the `ComponentDefinition` objects from a `Collection` referred to by the `fromCollection` property of the `Alternative`.

If the `roles` property of the template `Component` contains one or more URIs, then the `roles` property of the derived `Component` SHOULD also contain those URIs.

#### 2.2.2 Alternative.from

The `from` property is OPTIONAL and MAY contain zero or more URIs that each refer to a `ComponentDefinition`. This property specifies individual `ComponentDefinition` objects that are options when deriving a new `Component` from the template `Component`.

#### 2.2.3 Alternative.fromCollection

The `fromCollection` property is OPTIONAL and MAY contain zero or more URIs that each refer to a `Collection`. The `members` property of each `Collection` referred to in this way MUST NOT be empty and MUST refer only to `ComponentDefinition` objects. This property enables the convenient specification of new or existing groups of `ComponentDefinition` objects to serve as options when deriving a new `Component` from the template `Component`.

### 2.3 SequenceConstraint.restriction

In addition to the two new classes outlined above, we propose adding a new URI to the list of RECOMMENDED URIs for the `restriction` property of the `SequenceConstraint` class (Table 3). Previously, the `SequenceConstraint` class could be used to assert restrictions on the relative, sequence-based positions of a pair of `Component` objects, the `subject` and the `object`. This new URI raises the possibility of using the `SequenceConstraint` class to assert pairwise restrictions on `Component` identity and structure.

**Table 3:** RECOMMENDED URIs for the `restriction` property

| Restriction URI                   | Description |
|-----------------------------------|-------------|
| http://sbols.org/v2#differentFrom | The `definition` property of the `subject` `Component` MUST NOT refer to the same `ComponentDefinition` as that of the `object` `Component`. In addition, if the `sequence` properties of these `ComponentDefinition` objects are both not empty, then they MUST have different `elements` properties. |
  
3. Examples <a name='example'></a>
-------------------------------

## Enumerating a Library of GFP Reporters

Here we will specify the combinatorial design for a library of GFP reporters and enumerate all possible `ComponentDefinition` objects in accordance with it.

Given an abstract template `ComponentDefinition` that contains four sub-`Component` objects and three `SequenceConstraint` objects to fix their ordering,

```
gfpReporter : ComponentDefinition
  description = "An abstract GFP reporter"
  sequenceConstraint = glucoseSensitivePromoter precedes rbs1234
  sequenceConstraint = rbs1234 precedes gfp
  sequenceConstraint = gfp precedes terminator1234
```

a `Collection` of GFP CDS `ComponentDefinition` variants,

```
gfpLibrary : Collection
  description = "A library of various GFP CDSes"
  member = gfp1
  member = gfp2
  member = gfp3
```

and two glucose-sensitive promoter `ComponentDefinition` variants,

```
gluP_ABC : ComponentDefinition
  description = "Glucose-sensitive promoter"
  type = DNA
  role = Promoter

gluP_XYZ : ComponentDefinition
  description = "Glucose-sensitive promoter"
  type = DNA
  role = Promoter
```

we can define a `ComponentDerivation` that specifies a full enumeration using the GFP reporter as its template and the glucose-sensitive promoter and GFP library as its `alternatives`.

```
gfpReporterDerv1 : ComponentDerivation
  descrption = "Derive various more concrete designs from gfpReporter by choosing some alternatives for the promoter and GFP."
  using = gfpReporter 
  strategy = enumerate
  alternative : Alternative
    at = glucoseSensitivePromoter
    from = gluP_ABC
    from = gluP_XYZ
  alternative : Alternative
    at = gfp
    fromCollection = gfpLibrary
```

This `ComponentDerivation` could then serve as the basis for deriving a `Collection` of all six possible GFP reporter variants:

```
gfpReporterExp1 : Collection
  description = "Expansions of gfpReporterDerv1"

  prov:wasGeneratedBy : prov:Activity
    identity = gfpReporterExp1Activity
    prov:used = gfpReporterDerv1
    prov:wasAssociatedWith : prov:SoftwareAgent
      name = "expanderbot 2000"
      version = "0.1.3"
  
  member : ComponentDefinition
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
      prov:used:gluP_ABC
      prov:used:gfp1
    type = DNA
    role = Gene
    sequenceConstraint = gluP_ABC precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp1
    sequenceConstraint = gfp1 precedes terminator1234

  member : ComponentDefinition
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
      prov:used:gluP_XYZ
      prov:used:gfp1
    type = DNA
    role = Gene
    sequenceConstraint = gluP_XYZ precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp1
    sequenceConstraint = gfp1 precedes terminator1234

  member : ComponentDefinition
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
      prov:used:gluP_ABC
      prov:used:gfp2
    type = DNA
    role = Gene
    sequenceConstraint = gluP_ABC precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp2
    sequenceConstraint = gfp2 precedes terminator1234

  member : ComponentDefinition
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
      prov:used:gluP_XYZ
      prov:used:gfp2
    type = DNA
    role = Gene
    sequenceConstraint = gluP_XYZ precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp2
    sequenceConstraint = gfp2 precedes terminator1234

  member : ComponentDefinition
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
      prov:used:gluP_ABC
      prov:used:gfp3
    type = DNA
    role = Gene
    sequenceConstraint = gluP_ABC precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp3
    sequenceConstraint = gfp3 precedes terminator1234

  member : ComponentDefinition
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
      prov:used:gluP_XYZ
      prov:used:gfp3
    type = DNA
    role = Gene
    sequenceConstraint = gluP_XYZ precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp3
    sequenceConstraint = gfp3 precedes terminator1234
```

The provenance (`prov`) annotations are OPTIONAL, but ensure that there is a full history of how these entities were derived.

## Enumerating CDS Order in Operon

The `abstractOperon` design has `SequenceConstraint` objects to place two CDSes between a promoter and terminator, but does not constrain the relative ordering of the CDSes themselves.

```
abstractOperon : ComponentDefinition
  type = DNA
  role = Operon
  sequenceConstraint = p123 precedes orf1
  sequenceConstraint = p123 precedes orf2
  sequenceConstraint = orf1 precedes t567
  sequenceConstraint = orf2 precedes t567
```

This time we will specify a `ComponentDerivation` that does not include `Alternative` objects since we only want to enumerate all possible orderings of two non-abstract CDSses.

```
abstractOperonDer1 : ComponentDerivation
  description = "Derive the various unambiguous orderings 
  using = abstractOperon
  strategy = enumerate
```

Omitting provenance annotations, this `ComponentDerivation` will give us a `Collection` of two `ComponentDefinition` objects:

```
abstractOperonExp1 : Collection
  member : ComponentDefinition
    type = DNA
    role = Operon
    sequenceConstraint = p123 precedes orf1
    sequenceConstraint = orf1 precedes orf2
    sequenceConstraint = orf2 precedes t567
  member : ComponentDefinition
    type = DNA
    role = Operon
    sequenceConstraint = p123 precedes orf2
    sequenceConstraint = orf2 precedes orf1
    sequenceConstraint = orf1 precedes t567
```

Note that ordering of sub-`Component` objects within each newly derived `ComponentDefinition` is fixed with a new set of `SequenceConstraint` objects. Instead of using `SequenceConstraint` objects, a user could instead link the derived `ComponentDefinition` to a complete `Sequence` and use a set of `SequenceAnnotation` objects to designate the `Location` of each sub-`Component` such that the proper ordering is achieved.

## Different Enumerations from Same Template

We can have more than one derivation from the same template `ComponentDefinition`. Given the previous `ComponentDefinition` for a GFP reporter, 

```
gfpReporter : ComponentDefinition
  description = "An abstract GFP reporter"
  sequenceConstraint = glucoseSensitivePromoter precedes rbs1234
  sequenceConstraint = rbs1234 precedes gfp
  sequenceConstraint = gfp precedes terminator1234

we can specify two different derivations, one that varies the promoter sub-`Component`, and one that varies the CDS sub-`Component`.
  
der1 : ComponentDerivation
  using gfpReporter
  strategy = enumerate
  alternative : Alternative
    at = glucoseSensitivePromoter
    from = gluP_ABC
    from = gluP_XYZ
  
der2 : ComponentDerivation
  using gfpReporter
  strategy = enumerate
  alternative : Alternative
    at = gfp
    fromCollection = gfpLibrary
```

These derivations give rise to two independent families of enumerations from the same template design (again omitting provenance annotations):

```
exp1 : Collection
  member : ComponentDefinition
    sequenceConstraint = gluP_ABC precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp
    sequenceConstraint = gfp precedes terminator1234
  member : ComponentDefinition
    sequenceConstraint = gluP_XYZ precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp
    sequenceConstraint = gfp precedes terminator1234

exp2 : Collection
  member : ComponentDefinition
    sequenceConstraint = glucoseSensitivePromoter precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp1
    sequenceConstraint = gfp1 precedes terminator1234
  member : ComponentDefinition
    sequenceConstraint = glucoseSensitivePromoter precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp2
    sequenceConstraint = gfp2 precedes terminator1234
  member : ComponentDefinition
    sequenceConstraint = glucoseSensitivePromoter precedes rbs1234
    sequenceConstraint = rbs1234 precedes gfp3
    sequenceConstraint = gfp3 precedes terminator1234
```

Since each `ComponentDerivation` is external to its template `ComponentDefinition`, we could use this template as the target of another `ComponentDerivation` to further expand it out.

## Probablistic Sampling of GFP Reporter Library

Starting again with the GFP reporter template `ComponentDefinition, we could specify a `ComponentDerivation` that uses the `sample` `strategy` rather than the `enumerate` `strategy` that we have used so far.

```
der1 : ComponentDerivation
  using gfpReporter
  strategy = sample
  alternative : Alternative
    at = glucoseSensitivePromoter
    from = gluP_ABC
    from = gluP_XYZ
  alternative : Alternative
    at = gfp
    fromCollection = gfpLibrary
```

We can sample once to derive the following `ComponentDefinition`:

```
sampled1 : ComponentDefinition
  prov:wasGeneratedBy : prov:Activity
    identity = gfpReporterExp1Activity
    prov:used = der1
    prov:wasAssociatedWith : prov:SoftwareAgent
      name = "samplebot G1"
      version = "9.1"
      randomSeed = "9837453"^^xs:long
  sequenceConstraint = gluP_ABC precedes rbs1234
  sequenceConstraint = rbs1234 precedes gfp2
  sequenceConstraint = gfp2 precedes terminator1234
```

4. Backwards Compatibility <a name='compatibility'></a>
-----------------

New class, no issues anticipated.

5. Discussion <a name='discussion'></a>
-----------------

**Advantages:**

We have a complete log of the expansion options and of the individual expansions. 
You can also use provo annotations to document that a ComponentDefinition was made by expanding
a ComponentDerivation. It also gives you a separation between the abstract design and the strategy 
used to refine it into a concrete design. You could take the same template and expand it with 
several different ComponentDerivation instances with different sets of alternatives, 
or expand out that same template manually.


6. Competing SEPs <a name='competing_seps'></a>
-----------------

Currently none.


References <a name='references'></a>
----------------

[SBOL-Specification/#31]: https://github.com/SynBioDex/SBOL-specification/issues/31
[SBOL]: http://sbolstandard.org
[1]: https://www.python.org/dev/peps/pep-0001

Copyright <a name='copyright'></a>
-------------
<p xmlns:dct="http://purl.org/dc/terms/" xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#">
  <a rel="license"
     href="http://creativecommons.org/publicdomain/zero/1.0/">
    <img src="http://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;" alt="CC0" />
  </a>
  <br />
  To the extent possible under law,
  <a rel="dct:publisher"
     href="sbolstandard.org">
    <span property="dct:title">SBOL developers</span></a>
  has waived all copyright and related or neighboring rights to
  <span property="dct:title">SEP 007</span>.
This work is published from:
<span property="vcard:Country" datatype="dct:ISO3166"
      content="US" about="sbolstandard.org">
  United States</span>.
</p>
