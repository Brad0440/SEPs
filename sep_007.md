SEP 007 -- combinatorial design initial draft
===================================

SEP                     | <leave empty>
----------------------|--------------
**Title**                | combinatorial assemblies
**Authors**           | Matthew Pocock, Jacob Beal, Nicholas Roehner (nicholasroehner@gmail.com)
**Editor**            | Raik Gruenberg
**Type**               | Data Model
**SBOL Version** | 2.2
**Status**             | Draft
**Created**          | 19-Aug-2016
**Last modified**  |

Abstract
-----------

We propose adding two new classes, `CombinatorialDerivation` and `VariableComponent`, to allow users to represent basic combinatorial designs in SBOL without having to enumerate every possible design variant. For example, a user may wish to encode a library of reporter gene variants that have different promoters and ribosome binding sites (RBS) without having to create a `ComponentDefinition` for every possible combination of a promoter, RBS, and coding sequence (CDS) in their library. A `CombinatorialDerivation` refers to a single template `ComponentDefinition` from which new `ComponentDefinition` objects can be derived. Each `VariableComponent` in a `CombinatorialDerivation` specifies one or more possible definitions for any new sub-`Component` object derived from a `Component` in the template `ComponentDefinition`.

We also propose adding http://sbols.org/v2#differentFrom to the list of recommended URIs for the `restriction` property of the `SequenceConstraint` class. This would enable users to specify combinatorial designs in which the choice of a definition for one `Component` during a derivation can preclude the choice of that definition for another `Component` during the same derivation.

1. Rationale <a name="rationale"></a>
----------------

This SEP was initiated in response to [SBOL-Specification/#31]. Currently, there is no way to specify the composition of a genetic library or another combinatorial design for common use cases in synthetic biology, such as tuning the performance of a genetic circuit or biosynthetic pathway through combinatorial DNA assembly and screening. While a user could derive multiple `ComponentDefinition` objects from an abstract `ComponentDefinition` that lacks a `Sequence` or a total ordering of its sub-`Component` objects via `SequenceConstraint` objects, they would still be unable to use SBOL to specify a finite set of alternative structures to choose from during such a derivation. This SEP is intended to enable users of SBOL to explicitly denote the structural choices to be made and the basic strategy to be used (enumerate vs. sample) during the derivation of a `ComponentDefinition` in accordance with a combinatorial design. 

2. Specification <a name="specification"></a>
----------------------------------------------

Here we define two new classes, `CombinatorialDerivation` and `VariableComponent`, and provide an update to Table 9 of the SBOL 2.1.0 specification, adding http://sbols.org/v2#differentFrom to the list of recommended URIs for the `restriction` property of the `SequenceConstraint` class.

### 2.1 CombinatorialDerivation

The `CombinatorialDerivation` class can be used to specify a combinatorial design. `ComponentDefinition` objects that realize the design can be derived in accordance with the class properties `template`, `variableComponents`, and `strategy` (Figure 1).

![Component Derivation class UML diagram](images/sep_007_combinatorial_derivation.png "Component Derivation class UML diagram")

**Figure 1:** Diagram of the `CombinatorialDerivation` class and its associated properties

#### 2.1.1 CombinatorialDerivation.template

The `template` property is REQUIRED and MUST contain a URI that refers to a `ComponentDefinition`. This `ComponentDefinition` is expected to serve as a template for the derivation of new `ComponentDefinition` objects. Consequently, its `components` property SHOULD contain one or more `Component` objects that describe its substructure (referred to hereafter as template `Component` objects), and its `sequenceConstraints` property MAY also contain one or more `SequenceConstraint` objects that constrain this substructure. 

When a `ComponentDefinition` is derived in accordance with a `CombinatorialDerivation`, the `wasDerivedFrom` property of the derived `ComponentDefinition` SHOULD refer to the `CombinatorialDerivation`. When multiple `ComponentDefinition` objects are derived in accordance with the same `CombinatorialDerivation`, they MAY be referred to by the `members` property of a `Collection`, in which case the `wasDerivedFrom` property of the `Collection` SHOULD also refer to this `CombinatorialDerivation`.

If the `types` property of the `template` `ComponentDefinition` contains one or more URIs, then the `types` property of the derived `ComponentDefinition` SHOULD also contain those URIs. The same holds true for the `roles` properties of these `ComponentDefinition` objects.

#### 2.1.2 CombinatorialDerivation.variableComponents

The `variableComponents` property is OPTIONAL and MAY contain a set of `VariableComponent` objects. These `VariableComponent` objects are expected to denote the choices available when deriving the substructure of a new `ComponentDefinition` in accordance with a `CombinatorialDerivation`. The `variableComponents` property MUST NOT contain two or more `VariableComponent` objects that refer to the same template `Component` via their `variable` properties.

If the `variable` property of one of these `VariableComponent` objects refers to a template `Component`, then the `components` property of the derived `ComponentDefinition` SHOULD contain as many `Component` objects derived from the template `Component` as specified by the `operator` property of the `VariableComponent` (see Section 2.2.5 and Table 2). In addition, the `definition` properties of these derived `Component` objects MUST refer to `ComponentDefinition` objects specified by the `variants`, `variantCollections`, or `variantDerivations` property of the `VariableComponent` (see Section 2.2.1). 

If no `variable` property of one of these `VariableComponent` objects refers to a template `Component`, then the `components` property of the derived `ComponentDefinition` SHOULD contain exactly one `Component` with a `wasDerivedFrom` property that refers to the template `Component`. The `definition` property of this derived `Component` MUST refer to the `ComponentDefinition` referred to by the `definition` property of the template `Component`.

Finally, all of these derived `Component` objects MUST follow the `restriction` properties of any `SequenceConstraint` objects that refer to their corresponding template `Component` objects.

#### 2.1.3 CombinatorialDerivation.strategy

The `strategy` property is OPTIONAL and has a data type of URI. Table 1 provides a list of REQUIRED strategy URIs. If the `strategy` property is not empty, then it MUST contain a URI from Table 1. This property recommends how many `ComponentDefinition` objects a user SHOULD derive from the `template` `ComponentDefinition`.

**Table 1:** REQUIRED URIs for the `strategy` property

| Strategy URI                   | Description |
|-----------------------------------|-------------|
| http://sbols.org/v2#enumerate | A user SHOULD derive all `ComponentDefinition` objects with a unique substructure as specified by the `Component` objects contained by the `template` `ComponentDefinition` and the `VariableComponent` objects contained by the `CombinatorialDerivation`. |
| http://sbols.org/v2#sample    | A user SHOULD derive a subset of all `ComponentDefinition` objects with a unique substructure as specified by the `Component` objects contained by the `template` `ComponentDefinition` and the `VariableComponent` objects contained by the `CombinatorialDerivation`. The manner in which this subset is chosen is for the user to decide. |

### 2.2 VariableComponent

The `VariableComponent` class can be used to specify a choice of `ComponentDefinition` objects for any new `Component` derived from a template `Component` in the `template` `ComponentDefinition`. This specification is made using the class properties `variable`, `variants`, `variantCollections`, and `variantDerivations` (Figure 2). While the `variants`, `variantCollections`, and `variantDerivations` properties are OPTIONAL, at least one of them MUST NOT be empty.

![Alternative class UML diagram](images/sep_007_variable_component.png "Alternative class UML diagram")

**Figure 2:** Diagram of the `VariableComponent` class and its associated properties

#### 2.2.1 VariableComponent.variable

The `variable` property is REQUIRED and MUST contain a URI that refers to a template `Component` in the template `ComponentDefinition`. If the `wasDerivedFrom` property of a `Component` refers to this template `Component`, then the `definition` property of the derived `Component` MUST either (1) refer to one of the `ComponentDefinition` objects referred to by the `variants` property of the `VariableComponent`, (2) refer to one of the `ComponentDefinition` objects from a `Collection` referred to by the `variantCollections` property of the `VariableComponent`, or (3) refer to a `ComponentDefinition` derived from a `CombinatorialDerivation` referred to by the `variantDerivations` property of the `VariableComponent`.

If the `roles` property of the template `Component` contains one or more URIs, then the `roles` property of the derived `Component` SHOULD also contain those URIs.

#### 2.2.2 VariableComponent.variants

The `variants` property is OPTIONAL and MAY contain zero or more URIs that each refer to a `ComponentDefinition`. This property specifies individual `ComponentDefinition` objects to serve as options when deriving a new `Component` from the template `Component`.

#### 2.2.3 VariableComponent.variantCollections

The `variantCollections` property is OPTIONAL and MAY contain zero or more URIs that each refer to a `Collection`. The `members` property of each `Collection` referred to in this way MUST NOT be empty and MUST refer only to `ComponentDefinition` objects. This property enables the convenient specification of existing groups of `ComponentDefinition` objects to serve as options when deriving a new `Component` from the template `Component`.

#### 2.2.4 VariableComponent.variantDerivations

The `variantDerivations` property is OPTIONAL and MAY contain zero or more URIs that each refer to a `CombinatorialDerivation`. This property enables the convenient specification of `ComponentDefinition` objects derived in accordance with another `CombinatorialDerivation` to serve as options when deriving a new `Component` from the template `Component`. The `variantDerivations` property of a `VariableComponent` MUST NOT refer to the `CombinatorialDerivation` that contains this `VariableComponent`. Furthermore, `VariableComponent` objects MUST NOT form a cyclical chain of references via their `variantDerivations` properties and the `ComponentDerivation` objects that contain them. For example, consider the `VariableComponent` objects *A* and *B* and the `ComponentDerivation` objects *X* and *Y*. The reference chain *X* contains *A*, *A* has variant derivation *Y*, *Y* contains *B*, and *B* has variant derivation *X* is cyclical.

#### 2.2.5 VariableComponent.operator

The `operator` property is REQUIRED and has a data type of URI. This property specifies how many `Component` objects can be derived from the template `Component` during the derivation of a new `ComponentDefinition`. The URI value of this property MUST come from the REQUIRED `operator` URIs provided in Table 2.

**Table 2:** REQUIRED URIs for the `operator` property

| Operator URI                   | Description |
|-----------------------------------|-------------|
| http://sbols.org/v2#zeroOrOne | No more than one `Component` in the derived `ComponentDefinition` SHOULD have a `wasDerivedFrom` property that refers to the template `Component`. |
| http://sbols.org/v2#one   | Exactly one `Component` in the derived `ComponentDefinition` SHOULD have a `wasDerivedFrom` property that refers to the template `Component`. |
| http://sbols.org/v2#zeroOrMore | Any number of `Component` objects in the derived `ComponentDefinition` MAY have `wasDerivedFrom` properties that refer to the template `Component`.  |
| http://sbols.org/v2#oneOrMore | At least one `Component` in the derived `ComponentDefinition` SHOULD have a `wasDerivedFrom` property that refers to the template `Component`. |

### 2.3 SequenceConstraint.restriction

In addition to the two new classes outlined above, we propose adding a new URI to the list of RECOMMENDED URIs for the `restriction` property of the `SequenceConstraint` class (Table 3). Previously, the `SequenceConstraint` class could be used to assert restrictions on the relative, sequence-based positions of a pair of `Component` objects, the `subject` and the `object`. This new URI raises the possibility of using the `SequenceConstraint` class to assert pairwise restrictions on `Component` identity and structure.

**Table 3:** RECOMMENDED URIs for the `restriction` property

| Restriction URI                   | Description |
|-----------------------------------|-------------|
| http://sbols.org/v2#differentFrom | The `definition` property of the `subject` `Component` MUST NOT refer to the same `ComponentDefinition` as that of the `object` `Component`. In addition, if the `sequence` properties of these `ComponentDefinition` objects are both not empty, then they MUST have different `elements` properties. |
  
3. Examples <a name='example'></a>
-------------------------------

### 3.1 Enumerating a Combinatorial Library of GFP Reporters

Here we will specify the combinatorial design for a library of GFP reporters and enumerate all possible `ComponentDefinition` objects in accordance with it.

Given an abstract `template` `ComponentDefinition` that contains four sub-`Component` objects and three `SequenceConstraint` objects to fix their ordering,

```
gfpReporter : ComponentDefinition
  description = "An abstract GFP reporter"
  component : Component
    identity = glucose-sensitive_promoter
    definition = abstract_glucose-sensitive_promoter
  component : Component
    identity = rbs
    definition = rbs1
  component : Component
    identity = gfp
    definition = abstract_gfp
  component : Component
    identity = terminator
    definition = terminator1
  sequenceConstraint = glucose-sensitive_promoter precedes rbs
  sequenceConstraint = rbs precedes gfp
  sequenceConstraint = gfp precedes terminator
```

a `Collection` of GFP CDS `ComponentDefinition` variants,

```
gfpLibrary : Collection
  description = "A library of various GFP CDSes"
  member = gfp1
  member = gfp2
  member = gfp3
```

two glucose-sensitive promoter `ComponentDefinition` variants,

```
gluP_ABC : ComponentDefinition
  description = "Glucose-sensitive promoter"
  type = DNA
  role = Promoter

gluP_XYZ : ComponentDefinition
  description = "Glucose-sensitive promoter"
  type = DNA
  role = Promoter
```
a ribosome binding site, and a terminator,

```
rbs1 : ComponentDefinition
  description = "Elowitz RBS"
  type = DNA
  role = Ribosome Entry Site

terminator1 : ComponentDefinition
  description = "Double terminator"
  type = DNA
  role = Terminator
```

we can define a `CombinatorialDerivation` that specifies a full enumeration using the GFP reporter as its template and the glucose-sensitive promoter and GFP library as its `variableComponents`.

```
gfpReporterDerv1 : CombinatorialDerivation
  description = "Derive various more concrete designs from gfpReporter by choosing some VariableComponents for the promoter and GFP."
  template = gfpReporter 
  strategy = enumerate
  variableComponent : VariableComponent
    operator = one
    variable = glucose-sensitive_promoter
    variant = gluP_ABC
    variant = gluP_XYZ
  variableComponent : VariableComponent
    operator = one
    variable = gfp
    variantCollection = gfpLibrary
```

This `CombinatorialDerivation` can then serve as the basis for deriving a `Collection` of all six possible GFP reporter variants:

```
expanderbot2000 : prov:Agent
  name = "expanderbot 2000"
  version = "0.1.3"

gfpReporterExp1 : Collection
  description = "Expansions of gfpReporterDerv1"

  wasDerivedFrom = gfpReporterDerv1

  prov:wasGeneratedBy : prov:Activity
    identity = gfpReporterExp1Activity
    prov:qualifiedUsage : prov:Usage
      hadRole = source
      entity = gfpReporterDerv1
    prov:qualifiedAssociation : prov:Association
      hadRole = enumerator
      prov:agent = expanderbot2000
        
  member : ComponentDefinition
    wasDerivedFrom = gfpReporterDerv1
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
    type = DNA
    role = Gene
    component : Component
      identity = c1
      definition = glup_ABC
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = gfp1
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4

  member : ComponentDefinition
    wasDerivedFrom = gfpReporterDerv1
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
    type = DNA
    role = Gene
    component : Component
      identity = c1
      definition = glup_XYZ
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = gfp1
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4

  member : ComponentDefinition
    wasDerivedFrom = gfpReporterDerv1
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
    type = DNA
    role = Gene
    component : Component
      identity = c1
      definition = glup_ABC
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = gfp2
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4

  ...
```

The provenance objects are OPTIONAL, but ensure that there is a full history of how these entities were derived.

### 3.2 Enumerating CDS Order in an Operon

The operon1 `ComponentDefinition` has `SequenceConstraint` objects to position two CDSs between a promoter and terminator, but does not constrain the relative ordering of the CDSs themselves. For simplicity, the complete sub-`Component` objects and OPTIONAL provenance objects are omitted from this example.

```
operon1 : ComponentDefinition
  type = DNA
  role = Operon
  sequenceConstraint = p1 precedes orf1
  sequenceConstraint = p1 precedes orf2
  sequenceConstraint = orf1 precedes t1
  sequenceConstraint = orf2 precedes t1
```

This time we will specify a `CombinatorialDerivation` that does not contain `VariableComponent` objects since we only want to enumerate all possible orderings of these non-abstract `Component` objects.

```
abstractOperonDer1 : CombinatorialDerivation
  description = "Derive the various unambiguous orderings"
  template = abstractOperon
  strategy = enumerate
```

This `CombinatorialDerivation` will give us a `Collection` of two `ComponentDefinition` objects:

```
abstractOperonExp1 : Collection
  wasDerivedFrom = abstractOperonDer1

  member : ComponentDefinition
    wasDerivedFrom = abstractOperonDer1
    type = DNA
    role = Operon
    sequenceConstraint = p1 precedes orf1
    sequenceConstraint = orf1 precedes orf2
    sequenceConstraint = orf2 precedes t1

  member : ComponentDefinition
    wasDerivedFrom = abstractOperonDer1
    type = DNA
    role = Operon
    sequenceConstraint = p1 precedes orf2
    sequenceConstraint = orf2 precedes orf1
    sequenceConstraint = orf1 precedes t1
```

The ordering of sub-`Component` objects within each newly derived `ComponentDefinition` is fixed with a new set of `SequenceConstraint` objects. Note that, instead of using `SequenceConstraint` objects, a user can associate each derived `ComponentDefinition` with a complete `Sequence` and use a set of `SequenceAnnotation` objects to designate the `Location` of each sub-`Component` such that the proper ordering is achieved.

### 3.3 Different Enumerations from Same Template

We can have more than one derivation from the same `template` `ComponentDefinition`. Given the previous `ComponentDefinition` for a GFP reporter, we can specify two different derivations, one that varies the promoter sub-`Component`, and one that varies the CDS sub-`Component`.

```  
der1 : CombinatorialDerivation
  template = gfpReporter
  strategy = enumerate
  variableComponent : VariableComponent
    operator = one
    variable = glucose-sensitive_promoter
    variant = gluP_ABC
    variant = gluP_XYZ
  
der2 : CombinatorialDerivation
  template = gfpReporter
  strategy = enumerate
  variableComponent : VariableComponent
    operator = one
    variable = gfp
    variantCollection = gfpLibrary
```

These derivations give rise to two independent families of enumerations from the same template design (again omitting OPTIONAL provenance objects):

```
exp1 : Collection
  wasDerivedFrom = der1
  member : ComponentDefinition
    wasDerivedFrom = der1
    component : Component
      identity = c1
      definition = gluP_ABC
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = abstract_gfp
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4
  member : ComponentDefinition
    wasDerivedFrom = der1
    component : Component
      identity = c1
      definition = gluP_XYZ
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = abstract_gfp
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4

exp2 : Collection
  wasDerivedFrom = der2
  member : ComponentDefinition
    wasDerivedFrom = der2
    component : Component
      identity = c1
      definition = abstract_glucose-sensitive_promoter
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = gfp1
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4
  member : ComponentDefinition
    wasDerivedFrom = der2
    component : Component
      identity = c1
      definition = abstract_glucose-sensitive_promoter
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = gfp2
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4
  member : ComponentDefinition
    wasDerivedFrom = der2
    component : Component
      identity = c1
      definition = abstract_glucose-sensitive_promoter
      wasDerivedFrom = glucose-sensitive_promoter
    component : Component
      identity = c2
      definition = rbs1
      wasDerivedFrom = rbs
    component : Component
      identity = c3
      definition = gfp3
      wasDerivedFrom = gfp
    component : Component
      identity = c4
      definition = terminator1
      wasDerivedFrom = terminator
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4
```

Since each `CombinatorialDerivation` is external to its `template` `ComponentDefinition`, we could use this template as the target of another `CombinatorialDerivation` to further expand it out.

### 3.4 Probablistic Sampling of GFP Reporter Library

Starting again with the GFP reporter `template` `ComponentDefinition`, we can specify a `CombinatorialDerivation` that uses the `sample` `strategy` rather than the `enumerate` `strategy` that we have used so far.

```
der1 : CombinatorialDerivation
  template = gfpReporter
  strategy = sample
  variableComponent : VariableComponent
    operator = one
    variable = glucoseSensitivePromoter
    variant = gluP_ABC
    variant = gluP_XYZ
  variableComponent : VariableComponent
    operator = one
    variable = gfp
    variantCollection = gfpLibrary
```

We can sample once to derive the following `ComponentDefinition`:

```
samplebotG1 : prov:Agent
  name = "samplebot G1"
  version = "9.1"
  randomSeed = "9837453"^^xs:long

sampled1 : ComponentDefinition
  wasDerivedFrom = der1
  prov:wasGeneratedBy : prov:Activity
    prov:qualifiedUsage : prov:Usage
      hadRole = source
      entity = der1
    prov:qualifiedAssociation : prov:Association
      hadRole = sampler
      prov:agent = samplebotG1
  component : Component
    identity = c1
    definition = gluP_ABC
    wasDerivedFrom = glucose-sensitive_promoter
  component : Component
    identity = c2
    definition = rbs1
    wasDerivedFrom = rbs
  component : Component
    identity = c3
    definition = gfp2
    wasDerivedFrom = gfp
  component : Component
    identity = c4
    definition = terminator1
    wasDerivedFrom = terminator
  sequenceConstraint = c1 precedes c2
  sequenceConstraint = c2 precedes c3
  sequenceConstraint = c3 precedes c4
```
### 3.5 Sampling Promoters with Variable Numbers of Operator Sites

Here we will specify the combinatorial design for a eukaryotic promoter that contains a variable number of upstream operator sites.

Given an abstract `template` `ComponentDefinition` that contains two sub-`Component` objects and one `SequenceConstraint` object to fix their ordering,

```
synthCMV : ComponentDefinition
  description = "A eukaryotic promoter"
  component : Component
    identity = operator
    definition = abstract_operator
  component : Component
    identity = cmv
    definition = cmv1
  sequenceConstraint = operator precedes cmv
```
a `Collection` of operator site `ComponentDefinition` variants,

```
operatorLibrary : Collection
  description = "A library of operator site variants"
  member = operator1
  member = operator2
  member = operator3
  member = operator4
```
and a CMV promoter `ComponentDefinition`,

```
cmv1 : ComponentDefinition
  description = "CMV promoter"
  type = DNA
  role = Promoter
```

we can define a `CombinatorialDerivation` that specifies a sampling using the synthetic CMV promoter as its `template` and the operator library as the sole member of `variableComponents`.

```
synthCMVDerv1 : CombinatorialDerivation
  description = "Derive various concrete designs for the synthetic CMV promoter by choosing one or more upstream operator sites."
  template = synthCMV 
  strategy = sample
  variableComponent : VariableComponent
    operator = oneOrMore
    variable = operator
    variantCollection = operatorLibrary
```

This `CombinatorialDerivation` can then serve as the basis for deriving a `Collection` of synthetic CMV promoters with different numbers of upstream operator sites.

```
samplebotG1 : prov:Agent
  name = "samplebot G1"
  version = "9.1"
  randomSeed = "9837453"^^xs:long

synthCMVExp1 : Collection
  description = "Expansions of the synthetic CMV promtoer"

  wasDerivedFrom = synthCMVDerv1

  prov:wasGeneratedBy : prov:Activity
    identity = synthCMVExp1Activity
    prov:qualifiedUsage : prov:Usage
      hadRole = source
      entity = synthCMVDerv1
    prov:qualifiedAssociation : prov:Association
      hadRole = sampler
      prov:agent = samplebotG1
        
  member : ComponentDefinition
    wasDerivedFrom = synthCMVDerv1
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = synthCMVExp1Activity
    type = DNA
    role = Promoter
    component : Component
      identity = c1
      definition = operator2
      wasDerivedFrom = operator
    component : Component
      identity = c2
      definition = operator3
      wasDerivedFrom = operator
    component : Component
      identity = c3
      definition = operator2
      wasDerivedFrom = operator
    component : Component
      identity = c4
      definition = cmv1
      wasDerivedFrom = cmv
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4

  member : ComponentDefinition
    wasDerivedFrom = gfpReporterDerv1
    prov:wasGeneratedBy : prov:Activity
      prov:wasInformedBy = gfpReporterExp1Activity
    type = DNA
    role = Gene
    component : Component
      identity = c1
      definition = operator1
      wasDerivedFrom = operator
    component : Component
      identity = c2
      definition = operator4
      wasDerivedFrom = operator
    component : Component
      identity = c3
      definition = operator2
      wasDerivedFrom = operator
    component : Component
      identity = c4
      definition = operator3
      wasDerivedFrom = operator
    component : Component
      identity = c5
      definition = operator3
      wasDerivedFrom = operator
    component : Component
      identity = c6
      definition = cmv1
      wasDerivedFrom = cmv
    sequenceConstraint = c1 precedes c2
    sequenceConstraint = c2 precedes c3
    sequenceConstraint = c3 precedes c4
    sequenceConstraint = c4 precedes c5
    sequenceConstraint = c5 precedes c6

  ...
```

4. Backwards Compatibility <a name='compatibility'></a>
-----------------

New class, no issues anticipated.

5. Discussion <a name='discussion'></a>
-----------------

**Advantages:**

We have a complete log of the combinatorial expansion options and of the individual expansions. We can also use provenance objects to document that a `CombinatorialDerivation` was executed using a specific software tool. The proposed extension also gives us a separation between an abstract design and the strategy used to refine it into a concrete design. We can take the same template and expand it in accordance with several `CombinatorialDerivation` objects that present different sets of `VariableComponent` objects.


6. Competing SEPs <a name='competing_seps'></a>
-----------------

Currently none.


References <a name='references'></a>
----------------

[SBOL-Specification/#31]: https://github.com/SynBioDex/SBOL-specification/issues/31
[SBOL]: http://sbolstandard.org
[1]: https://www.python.org/dev/peps/pep-0001

Copyright <a name='copyright'></a>
-------------
<p xmlns:dct="http://purl.org/dc/terms/" xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#">
  <a rel="license"
     href="http://creativecommons.org/publicdomain/zero/1.0/">
    <img src="http://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;" alt="CC0" />
  </a>
  <br />
  To the extent possible under law,
  <a rel="dct:publisher"
     href="sbolstandard.org">
    <span property="dct:title">SBOL developers</span></a>
  has waived all copyright and related or neighboring rights to
  <span property="dct:title">SEP 007</span>.
This work is published from:
<span property="vcard:Country" datatype="dct:ISO3166"
      content="US" about="sbolstandard.org">
  United States</span>.
</p>
